"""Tests for the ``vlmd_submission_tools.subcommands.UploadDictionaryToMds`` subcommand"""
import os
from typing import NamedTuple
from unittest.mock import MagicMock, patch

import json
import pytest
import requests
import uuid

from utils import cleanup_files
from vlmd_submission_tools.common import config
from vlmd_submission_tools.subcommands import UploadDictionaryToMds


class MockArgs(NamedTuple):
    json_local_path: str
    dictionary_name: str
    is_valid_dictionary: str
    study_id: str
    output: str


class TestGetDictionaryUrlSubcommand:

    def get_mock_args(self,is_valid_dictionary='True'):
        return MockArgs(
            json_local_path="tests/templates/template_submission_minimal.json",
            dictionary_name="Minimal_json_dict",
            is_valid_dictionary=is_valid_dictionary,
            study_id="my_study_id",
            output="upload_output.json",
        )

    @patch('vlmd_submission_tools.common.utils.check_mds_study_id')
    @patch('vlmd_submission_tools.common.utils.get_client_secret')
    @patch('vlmd_submission_tools.common.utils.get_client_token')
    @patch('requests.post')
    @patch('requests.put')
    def test_upload_dictionary_to_mds(
        self,
        mocked_mds_put,
        mocked_mds_post,
        mocked_client_token,
        mocked_client_secret,
        mocked_check_mds,
    ):

        args = self.get_mock_args()

        mock_new_guid = "bbf91e87-837d-4f36-88b8-96e83bd77e9a"
        vlmd_for_study = {
            "data_dictionaries": {
                "CVS baseline": "guid-1",
                "JSON followup": "guid-2"
            },
            "common_data_elements" : {"foo": "bar"}
        }
        mocked_check_mds.return_value = vlmd_for_study

        mocked_client_secret.return_value = {"client_id": "client_id", "client_secret": "client_secret"}
        mocked_client_token.return_value = "my_client_token"

        # read json dictionary from local file
        with open(args.json_local_path, 'r') as fh:
            json_dictionary = json.load(fh)
        mocked_post_response = MagicMock(requests.Response)
        mocked_post_response.status_code = 200
        post_request_data = {
            "_guid_type": "data_dictionary",
            "title": args.dictionary_name,
            "data_dictionary": json_dictionary
        }
        mocked_post_response.json.return_value = post_request_data
        mocked_mds_post.return_value = mocked_post_response

        # use a mock guid for a placeholder for the mock response
        vlmd_for_study['data_dictionaries'][args.dictionary_name] = mock_new_guid
        new_metadata = {
            "_guid_type": "discovery_metadata",
            "gen3_discovery": "discovery_metadata",
            "variable_level_metadata": vlmd_for_study,
        }
        mocked_put_response = MagicMock(requests.Response)
        mocked_put_response.status_code = 200
        mocked_put_response.json.return_value = new_metadata
        mocked_mds_put.return_value = mocked_put_response

        try:
            UploadDictionaryToMds.main(options=args)

            # output artifact should have the dictionary name and guid
            with open(args.output, 'r') as fh:
                result_json = json.load(fh)
            assert result_json.get("upload_status") == "ok"
            assert result_json.get("dictionary_name") == args.dictionary_name
            new_guid = result_json.get("mds_guid")
            try:
                uuid.UUID(new_guid)
                assert True
            except ValueError:
                assert False

            # check the post request with the data dictionary
            mocked_mds_post.assert_called_with(
                f'https://{config.HOST_NAME}/mds/metadata/{new_guid}',
                headers={'Authorization': 'bearer my_client_token', 'content-type': 'application/json'},
                json=post_request_data
            )

            # get the actual guid generated by update
            vlmd_for_study['data_dictionaries'][args.dictionary_name] = new_guid

            # check that request to update the study VLMD includes the updated VLMD
            mocked_mds_put.assert_called_with(
                f'https://{config.HOST_NAME}/mds/metadata/my_study_id?merge=True',
                headers={'Authorization': 'bearer my_client_token', 'content-type': 'application/json'},
                json={'variable_level_metadata': vlmd_for_study}
            )

        finally:
            cleanup_files([args.output])


    @patch('vlmd_submission_tools.common.utils.check_mds_study_id')
    @patch('vlmd_submission_tools.common.utils.get_client_secret')
    @patch('vlmd_submission_tools.common.utils.get_client_token')
    @patch('requests.post')
    def test_upload_dictionary_to_mds_failed_upload(self, mocked_mds_post, mocked_client_token, mocked_client_secret, mocked_check_mds):

        args = self.get_mock_args()
        existing_data_dictionaries = {
            "CVS baseline": "guid-1",
            "JSON followup": "guid-2"
        }
        mocked_check_mds.return_value = existing_data_dictionaries

        mocked_client_secret.return_value = {"client_id": "client_id", "client_secret": "client_secret"}
        mocked_client_token.return_value = "my_client_token"

        mocked_mds_post.side_effect = Exception("Mocked error")

        expected_error = "Could not post dictionary to metadata"
        with pytest.raises(Exception, match=expected_error):
            UploadDictionaryToMds.main(options=args)
        assert os.path.exists(args.output) == False


    @patch('vlmd_submission_tools.common.utils.check_mds_study_id')
    @patch('vlmd_submission_tools.common.utils.get_client_secret')
    @patch('vlmd_submission_tools.common.utils.get_client_token')
    @patch('requests.post')
    @patch('requests.put')
    def test_upload_dictionary_to_mds_failed_update(self, mocked_mds_put, mocked_mds_post, mocked_client_token, mocked_client_secret, mocked_check_mds):

        args = self.get_mock_args()
        existing_data_dictionaries = {
            "CVS baseline": "guid-1",
            "JSON followup": "guid-2"
        }
        mocked_check_mds.return_value = existing_data_dictionaries

        mocked_client_secret.return_value = {"client_id": "client_id", "client_secret": "client_secret"}
        mocked_client_token.return_value = "my_client_token"

        # read json dictionary from local file
        with open(args.json_local_path, 'r') as fh:
            json_dictionary = json.load(fh)
        mocked_post_response = MagicMock(requests.Response)
        mocked_post_response.status_code = 200
        mocked_post_response.json.return_value = {
            "_guid_type": "data_dictionary",
            "data_dictionary": json_dictionary
        }
        mocked_mds_post.return_value = mocked_post_response

        mocked_mds_put.side_effect = Exception("Mocked error")

        expected_error = "Could not update data_dictionaries in study ID metadata"
        with pytest.raises(Exception, match=expected_error):
            UploadDictionaryToMds.main(options=args)
        assert os.path.exists(args.output) == False


    def test_upload_dictionary_to_mds_invalid_dict(self):

        args = self.get_mock_args(is_valid_dictionary='False')
        expected_output =  {
            "upload_status": None,
            "dictionary_name": args.dictionary_name,
            "mds_guid": None
        }

        UploadDictionaryToMds.main(options=args)
        assert os.path.exists(args.output)
        with open(args.output, 'r') as fh:
            result_json = json.load(fh)
        assert result_json == expected_output
